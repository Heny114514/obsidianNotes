# 核心概念
## 1. Client (客户端)

客户端是分布式系统的调用者，它向服务发送请求并等待执行结果。

*   **角色与行为**：
    *   **发起请求**：客户端向主节点（Primary）发送请求 `<REQUEST, o, t, c>`。其中 `o` 是操作，`t` 是时间戳，`c` 是客户端ID。
    *   **广播策略**：通常客户端只发给主节点。但如果在超时时间内没收到回复，客户端会将请求**广播**给所有副本（Replicas）。
    *   **等待回复**：这是 BFT 的关键点。客户端不能只信任一个回复。它必须等待 **$f+1$** 个来自不同副本的、结果相同的回复。
    *   **为什么是 $f+1$？**：因为系统最多允许 $f$ 个节点是恶意的（拜占庭故障）。如果 $f$ 个节点撒谎，那么第 $f+1$ 个相同的回复必然来自一个诚实的节点。既然诚实节点遵循确定性算法，那么这个结果就是正确的。

*   **一次性语义 (Exactly-once)**：
    *   客户端为每个请求附加一个单调递增的时间戳 `t`。副本会记录每个客户端最近执行的请求时间戳，如果收到旧的时间戳，直接丢弃或重发旧结果，防止重放攻击。

## 2. Replica (副本/节点)

副本是运行服务代码和 PBFT 协议的服务器节点。

*   **数量要求 ($N = 3f + 1$)**：
    *   为了容忍 $f$ 个拜占庭故障节点，系统总共需要至少 $N = 3f + 1$ 个副本。
    *   **原因**：PBFT 需要在两轮投票中达成多数一致。考虑到可能有 $f$ 个恶意节点不响应或撒谎，以及网络异步导致最慢的 $f$ 个节点还没回复，系统必须依靠剩下的 $N - 2f$ 个节点达成共识。为了保证这 $N-2f$ 个节点中多数派是诚实的，必须满足 $N > 3f$。

*   **状态机**：
    *   所有副本都是确定性的状态机。给定相同的初始状态和相同的请求执行序列，它们必须产生相同的输出和最终状态。

*   **身份验证**：
    *   所有副本之间、副本与客户端之间都通过公钥签名或消息认证码（MAC）进行通信，确保消息未被篡改且来源真实。

## 3. View (视图)

视图是 PBFT 算法中的一个逻辑时间段或“任期”概念，用于确定谁是主节点。

*   **定义**：
    *   视图由连续的整数编号 $v$ 表示（从 0 开始）。
    *   在任何时刻，系统都处于某个特定的视图 $v$ 中。

*   **作用**：
    *   **确定主节点**：视图的主要目的是通过确定性公式选出主节点，避免复杂的选举过程。
    *   **公式**：在视图 $v$ 中，主节点 $p$ 的编号为 $p = v \mod N$。
    *   **活跃性 (Liveness)**：当主节点失效（不响应或作恶）时，系统通过**视图切换 (View Change)** 进入视图 $v+1$，从而更换主节点，保证系统继续运行。

## 4. Primary (主节点)

主节点是当前视图 $v$ 中的“领导者”或“排序者”。

*   **核心职责**：
    *   **排序 (Ordering)**：主节点不直接执行请求，而是负责为客户端的请求分配一个唯一的**序列号 (Sequence Number, n)**。
    *   **发起协议**：主节点构造 `Pre-prepare` 消息并广播给所有备份节点，提议：“在视图 $v$ 中，序列号 $n$ 应该被分配给请求 $m$”。

*   **潜在风险**：
    *   主节点可能是恶意的（拜占庭节点）。它可能会给不同的请求分配相同的序列号，或者故意丢弃请求。
    *   因此，PBFT 算法的大部分机制（如 Prepare 和 Commit 阶段）都是为了让备份节点检查和验证主节点的行为。

## 5. Backup (备份节点)

所有不是当前主节点的副本都是备份节点。

*   **核心职责**：
    *   **验证者**：备份节点收到主节点的 `Pre-prepare` 消息后，会验证签名、视图编号以及序列号是否合法。
    *   **共识参与者**：备份节点通过互相发送 `Prepare` 和 `Commit` 消息来确认：
        1.  所有诚实节点都收到了相同的请求建议。
        2.  确认该请求已经在全网达成一致。
    *   **监督者 (Watchdog)**：备份节点维护一个计时器。如果收到客户端请求后，在规定时间内没有看到主节点发起处理流程，或者执行过慢，备份节点会发起“视图切换”投票，试图推翻当前主节点。

# Normal-Case Operation

1. Client向Primary发送请求`Request`
2. Primary接受请求后向所有Backup发送`Pre-prepare`消息，并提议将`Request`编号为$m$
3. Backup验证`Pre-prepare`消息后向所有Replica发送`Prepare`消息
4. Replica接受到$2f+1$个有效相同的`prepare`消息（包括Primary的`Pre-prepare`）后，向所有Replica发送`Commit`消息
5. Replica接受$2f+1$个有效相同的`Commit`（包括自己），向Client返回`Reply`
6. Client接收到$f+1$个相同的`Reply`，即为操作结果

# View Changes
当相应超时时，Replica进行View Change

1. Backup向所有Replica广播`View-Change`，提议将View切换为$v+1$，同时附带接收到的$2f$个`Prepare`消息的Replica集合
2. 新Primary $p'$接收到$2f+1$个有效`View-Change`消息（通常包括自己）后，向所有Replica广播`New-View`消息，将Request$m$带入新View

# 正确性证明*

## Pre-prepare + Prepare
保证了同一视图下关于$m$的共识

假设恶意主节点试图让$m$和$m'$达成`Prepared`状态
那么有至少$2f+1$个节点支持$m$；有至少$2f+1$个节点支持$m'$
其中至少有$f+1$个相同节点，由于恶意节点最多有$f$个，其中至少有一个诚实节点
而诚实节点不会发送矛盾的`Prepare`消息，故假设无法实现

## Commit + View-Change
保证了跨视图下关于$m$的共识

若在有部分节点提交`Reply`消息时发生视图切换
View-Change消息需要携带$2f+1$个关于$m$的`prepare`消息
而新主节点需要等待$2f+1$个`View-Change`消息
其中有至少$f+1$个相同节点，至少有一个诚实节点既有对$m$`prepared`状态的记录，又有对新视图的投票
因此可以保证$m$传递至新视图